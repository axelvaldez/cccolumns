<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCCOLUMNS</title>
    <!-- Version: 1.1.0 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #f5f5f5;
        }

        #app {
            display: flex;
            height: calc(100vh - 30px);
            overflow-x: auto;
            overflow-y: hidden;
        }

        #app.hidden {
            display: none;
        }

        .column {
            flex-shrink: 0;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow-y: hidden;
        }

        .column-title {
            font-size: 16px;
            font-weight: 600;
            padding: 12px 16px;
            background: #000;
            color: white;
            cursor: pointer;
            flex-shrink: 0;
            border: none;
        }

        .column-title:hover {
            background: #333;
        }

        .column-title.editing {
            outline: 2px solid #007bff;
            outline-offset: -2px;
            cursor: text;
        }

        .column-content {
            flex: 1;
            position: relative;
            overflow-y: auto;
            padding: 20px;

            img{
                max-width: 100%;
                height: auto;
            }
        }

        .markdown-view {
            padding: 12px;
            line-height: 1.6;
            min-height: 100%;
        }

        .markdown-view h1 { margin: 20px 0 10px; font-size: 2em; }
        .markdown-view h2 { margin: 18px 0 9px; font-size: 1.5em; }
        .markdown-view h3 { margin: 16px 0 8px; font-size: 1.25em; }
        .markdown-view p { margin: 10px 0; }
        .markdown-view ul, .markdown-view ol { margin: 10px 0; padding-left: 30px; }
        .markdown-view li { margin: 4px 0; }
        .markdown-view code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: monospace; }
        .markdown-view pre { background: #f4f4f4; padding: 12px; border-radius: 4px; overflow-x: auto; margin: 10px 0; }
        .markdown-view pre code { background: none; padding: 0; }
        .markdown-view blockquote { border-left: 4px solid #ddd; padding-left: 16px; margin: 10px 0; color: #666; }
        .markdown-view a { color: #007bff; text-decoration: none; }
        .markdown-view a:hover { text-decoration: underline; }

        .markdown-editor {
            width: 100%;
            height: 100%;
            border: none;
            resize: none;
            font-family: monospace;
            font-size: 14px;
            padding: 12px;
            line-height: 1.6;
            background: #fafafa;
            border: 2px solid #007bff;
            border-radius: 4px;
            outline: none;
        }

        .edit-mode-indicator {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #007bff;
            color: white;
            padding: 0 20px;
            height: 30px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 500;
            z-index: 1001;
        }

        .edit-mode-indicator.active {
            display: flex;
        }

        #settings-button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 28px;
            padding: 0;
            margin-left: 8px;
            color: #666;
        }

        #settings-button:hover {
            color: #333;
        }

        #settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .settings-content h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }

        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }

        .settings-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.2s;
        }

        .settings-tab:hover {
            color: #333;
        }

        .settings-tab.active {
            color: #007bff;
            border-bottom-color: #007bff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .setting-item {
            margin-bottom: 20px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .setting-item input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .columns-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
        }

        .column-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            cursor: move;
        }

        .column-item.dragging {
            opacity: 0.5;
        }

        .column-item.drag-over {
            border-top: 3px solid #007bff;
        }

        .column-item-drag-handle {
            margin-right: 8px;
            color: #999;
            cursor: move;
        }

        .column-item span {
            flex: 1;
        }

        .column-item-buttons {
            display: flex;
            gap: 4px;
        }

        .column-item button {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .column-item button:hover {
            background: #c82333;
        }

        .add-column-btn {
            width: 100%;
            padding: 10px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-top: 10px;
        }

        .add-column-btn:hover {
            background: #218838;
        }

        .settings-help {
            margin-top: 20px;
            padding: 12px;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
        }

        .sync-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }

        .sync-section h3 {
            font-size: 18px;
            margin-bottom: 15px;
        }

        .setting-item input[type="text"],
        .setting-item input[type="password"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: monospace;
        }

        .sync-status {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
        }

        .sync-status.success {
            background: #d4edda;
            color: #155724;
        }

        .sync-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .sync-status.info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .sync-button {
            width: 100%;
            padding: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-top: 10px;
        }

        .sync-button:hover {
            background: #0056b3;
        }

        .sync-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        /* Login screen */
        #login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: #f5f5f5;
        }

        #login-screen.hidden {
            display: none;
        }

        .login-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 5px;
            color: #333;
        }

        .login-legend {
            font-size: 16px;
            color: #666;
            margin-bottom: 20px;
            max-width: 400px;
            text-align: center;
            font-style: italic;
        }

        .login-input {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            width: 300px;
            text-align: center;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .login-input:focus {
            outline: none;
            box-shadow: 0 2px 12px rgba(0,123,255,0.3);
        }

        .login-error {
            color: #dc3545;
            margin-top: 10px;
            font-size: 14px;
        }

        .local-only-link {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }

        .local-only-link a {
            color: #007bff;
            text-decoration: none;
            cursor: pointer;
        }

        .local-only-link a:hover {
            text-decoration: underline;
        }

        /* Status bar */
        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: white;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-size: 12px;
            z-index: 1000;
        }

        #status-bar.hidden {
            display: none;
        }

        .status-message {
            color: #666;
            flex: 1;
        }

        .status-bar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logout-btn {
            background: none;
            border: none;
            color: #007bff;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }

        .logout-btn:hover {
            color: #0056b3;
        }
    </style>
</head>
<body>
    <div id="login-screen">
        <div class="login-title">CCCOLUMNS</div>
        <div class="login-legend">Enter thy secret cipher, that thou mayst gain passage unto thine hallowed scriptures</div>
        <input type="password" id="password-input" class="login-input" autofocus>
        <div class="login-error" id="login-error"></div>
        <div class="local-only-link">
            <a href="#" id="local-only-link">or enter in local-only mode</a>
        </div>
    </div>

    <div class="edit-mode-indicator" id="edit-indicator">EDIT MODE - Press Esc to save</div>

    <div id="settings-modal">
        <div class="settings-content">
            <h2>Settings</h2>
            
            <div class="settings-tabs">
                <button class="settings-tab active" data-tab="columns">Columns</button>
                <button class="settings-tab" data-tab="sync">GitHub Sync</button>
                <button class="settings-tab" data-tab="backup">Backup & Restore</button>
                <button class="settings-tab" data-tab="install" style="display: none;">Install</button>
            </div>

            <div class="tab-content active" id="tab-columns">
                <div class="setting-item">
                    <label for="visible-columns">Visible Columns:</label>
                    <input type="number" id="visible-columns" min="1" max="10" value="3">
                </div>

                <div class="setting-item">
                    <label>Manage Columns:</label>
                    <div class="columns-list" id="columns-list"></div>
                    <button class="add-column-btn" id="add-column-btn">+ Add Column</button>
                </div>

                <div class="settings-help" style="margin-top: 20px;">
                    <strong>Hotkeys:</strong><br>
                    Ctrl+E - Enter/Exit Edit Mode<br>
                    Ctrl+, - Open Settings<br>
                    Esc - Save & Close
                </div>
            </div>

            <div class="tab-content" id="tab-sync">
                <div class="setting-item">
                    <label for="github-token">Personal Access Token:</label>
                    <input type="password" id="github-token" placeholder="ghp_...">
                </div>

                <div class="setting-item">
                    <label for="github-repo">Repository (owner/repo):</label>
                    <input type="text" id="github-repo" placeholder="your-username/repository-name">
                </div>

                <button class="sync-button" id="sync-now-btn">Sync Now</button>
                <div id="sync-status"></div>
                
                <div class="settings-help" style="margin-top: 15px;">
                    <strong>Setup:</strong><br>
                    1. Create a private GitHub repo<br>
                    2. Generate a token at github.com/settings/tokens (needs 'repo' scope)<br>
                    3. Enter token and repo above<br>
                    4. Data syncs automatically on changes
                </div>
            </div>

            <div class="tab-content" id="tab-backup">
                <div class="setting-item">
                    <label>Backup Data:</label>
                    <button class="sync-button" id="backup-download-btn">Download Backup</button>
                </div>

                <div class="setting-item" style="margin-top: 30px;">
                    <label for="backup-upload">Restore from Backup:</label>
                    <input type="file" id="backup-upload" accept=".json" style="display: none;">
                    <button class="sync-button" id="backup-upload-btn">Choose File to Restore</button>
                    <div id="backup-status" style="margin-top: 10px; font-size: 13px; color: #666;"></div>
                </div>

                <div class="settings-help" style="margin-top: 15px;">
                    <strong>About Backup & Restore:</strong><br>
                    â€¢ Download creates a JSON file with all your data<br>
                    â€¢ Restore replaces current data with backup file<br>
                    â€¢ Backup includes all columns and settings<br>
                    â€¢ Keep backups in a safe location
                </div>
            </div>

            <div class="tab-content" id="tab-install" style="display: none;">
                <div class="setting-item">
                    <h3 style="margin-bottom: 15px;">Install Your Own Instance</h3>
                    <p style="margin-bottom: 15px; line-height: 1.6;">
                        You're currently using CCCOLUMNS in local-only mode. Your data is saved only in your browser and is not synced or backed up anywhere.
                    </p>
                    <p style="margin-bottom: 15px; line-height: 1.6;">
                        To enable cloud backup and sync across devices, you can install your own instance of CCCOLUMNS:
                    </p>
                    <ol style="line-height: 1.8; margin-left: 20px; margin-bottom: 20px;">
                        <li>Fork or clone the repository from GitHub</li>
                        <li>Set up your own password protection</li>
                        <li>Deploy to your preferred hosting service</li>
                        <li>Configure GitHub sync for cloud backup</li>
                    </ol>
                    <a href="https://github.com/axelvaldez/cccolumns" target="_blank" style="display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; margin-top: 10px;">View on GitHub</a>
                </div>

                <div class="settings-help" style="margin-top: 20px;">
                    <strong>Note:</strong><br>
                    â€¢ Local-only mode stores data only in your browser<br>
                    â€¢ Clearing browser data will delete your content<br>
                    â€¢ Use the Backup tab to download your data regularly<br>
                    â€¢ Installing your own instance gives you full control
                </div>
            </div>
        </div>
    </div>

    <div id="app" class="hidden"></div>

    <div id="status-bar" class="hidden">
        <div class="status-message" id="status-message"></div>
        <div class="status-bar-right">
            <button class="logout-btn" id="logout-btn">Logout</button>
            <button id="settings-button" title="Settings (Ctrl+,)">âš™</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // Password protection
        // To set your password, generate SHA-256 hash of your password at: https://emn178.github.io/online-tools/sha256.html
        // Replace the hash below with your password's hash
        const PASSWORD_HASH = '47bf9eec014b3707612577ed1c2cb2e860937c78080abd8240c71a5ddedcd1e2';
        
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function checkAuth() {
            const authToken = localStorage.getItem('catch-all-auth');
            const localOnlyMode = localStorage.getItem('catch-all-local-only');
            return authToken === PASSWORD_HASH || localOnlyMode === 'true';
        }

        function isLocalOnlyMode() {
            return localStorage.getItem('catch-all-local-only') === 'true';
        }

        function showApp() {
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('app').classList.remove('hidden');
            document.getElementById('status-bar').classList.remove('hidden');
            document.getElementById('settings-button').classList.remove('hidden');
            // Initialize the app
            new CatchAllApp();
        }

        function showLogin() {
            document.getElementById('login-screen').classList.remove('hidden');
            document.getElementById('app').classList.add('hidden');
            document.getElementById('status-bar').classList.add('hidden');
            document.getElementById('settings-button').classList.add('hidden');
        }

        document.getElementById('password-input').addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const password = e.target.value;
                const hash = await hashPassword(password);
                
                if (hash === PASSWORD_HASH) {
                    localStorage.setItem('catch-all-auth', hash);
                    showApp();
                } else {
                    document.getElementById('login-error').textContent = 'Invalid password';
                    e.target.value = '';
                }
            }
        });

        document.getElementById('logout-btn').addEventListener('click', () => {
            localStorage.removeItem('catch-all-auth');
            localStorage.removeItem('catch-all-local-only');
            location.reload();
        });

        document.getElementById('local-only-link').addEventListener('click', (e) => {
            e.preventDefault();
            localStorage.setItem('catch-all-local-only', 'true');
            showApp();
        });

        // CatchAllApp class will be defined below, then auth check runs at the end

        class CatchAllApp {
            constructor() {
                console.log('CatchAllApp constructor called');
                this.columns = this.loadColumns();
                console.log('Loaded columns:', this.columns);
                this.visibleColumns = this.loadVisibleColumns();
                this.editMode = false;
                this.editingTitle = null;
                this.localOnlyMode = isLocalOnlyMode();
                this.githubToken = localStorage.getItem('catch-all-github-token') || '';
                this.githubRepo = localStorage.getItem('catch-all-github-repo') || '';
                this.syncInProgress = false;
                this.lastSyncTime = null;
                
                this.init();
                this.setupSettingsTabs();
                this.setupEventListeners();
                console.log('About to render');
                this.render();
                console.log('Render complete');
                
                // Show initial status bar message
                this.updateStatusBarMessage();
                
                // Try to sync on load if configured and not in local-only mode
                if (!this.localOnlyMode && this.githubToken && this.githubRepo) {
                    this.syncFromGitHub();
                }
            }

            init() {
                // Initialize with 3 columns if none exist
                if (this.columns.length === 0) {
                    this.columns = [
                        { id: 1, title: 'Column 1', content: '# Welcome\n\nStart typing here...' },
                        { id: 2, title: 'Column 2', content: '# Ideas\n\nYour ideas go here...' },
                        { id: 3, title: 'Column 3', content: '# Notes\n\nTake notes here...' }
                    ];
                    this.saveColumns();
                }
            }

            setupSettingsTabs() {
                // Hide/show tabs based on local-only mode
                const syncTab = document.querySelector('[data-tab="sync"]');
                const backupTab = document.querySelector('[data-tab="backup"]');
                const installTab = document.querySelector('[data-tab="install"]');
                
                const syncContent = document.getElementById('tab-sync');
                const installContent = document.getElementById('tab-install');
                
                if (this.localOnlyMode) {
                    // In local-only mode: show Columns, Backup, and Install tabs
                    if (syncTab) syncTab.style.display = 'none';
                    if (installTab) installTab.style.display = 'block';
                    if (syncContent) syncContent.style.display = 'none';
                    if (installContent) installContent.style.display = 'none'; // Start hidden, will show when tab clicked
                } else {
                    // In authenticated mode: show Columns, GitHub Sync, and Backup tabs
                    if (installTab) installTab.style.display = 'none';
                    if (syncTab) syncTab.style.display = 'block';
                    if (syncContent) syncContent.style.display = 'none'; // Start hidden, will show when tab clicked
                    if (installContent) installContent.style.display = 'none';
                }
            }

            loadColumns() {
                const saved = localStorage.getItem('catch-all-columns');
                return saved ? JSON.parse(saved) : [];
            }

            saveColumns() {
                localStorage.setItem('catch-all-columns', JSON.stringify(this.columns));
                // Auto-sync to GitHub if configured and not in local-only mode
                if (!this.localOnlyMode && this.githubToken && this.githubRepo && !this.syncInProgress) {
                    this.debouncedSyncToGitHub();
                }
            }

            loadVisibleColumns() {
                const saved = localStorage.getItem('catch-all-visible-columns');
                return saved ? parseInt(saved) : 3;
            }

            saveVisibleColumns() {
                localStorage.setItem('catch-all-visible-columns', this.visibleColumns.toString());
            }

            setupEventListeners() {
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Number keys 1-9 to change visible columns (only when not editing)
                    if (!this.editMode && !this.editingTitle && !document.getElementById('settings-modal').classList.contains('active')) {
                        const key = e.key;
                        if (key >= '1' && key <= '9') {
                            const requestedColumns = parseInt(key);
                            // Set to requested or max available columns
                            this.visibleColumns = Math.min(requestedColumns, this.columns.length);
                            this.saveVisibleColumns();
                            this.render();
                            return;
                        }
                    }
                    
                    // Ctrl+E for edit mode
                    if (e.ctrlKey && e.key === 'e') {
                        e.preventDefault();
                        this.toggleEditMode();
                    }
                    
                    // Ctrl+, for settings
                    if (e.ctrlKey && e.key === ',') {
                        e.preventDefault();
                        this.openSettings();
                    }
                    
                    // Esc to exit edit mode or close settings
                    if (e.key === 'Escape') {
                        if (document.getElementById('settings-modal').classList.contains('active')) {
                            this.closeSettings();
                        } else if (this.editingTitle !== null) {
                            this.exitTitleEdit();
                        } else if (this.editMode) {
                            this.toggleEditMode();
                        }
                    }
                });

                // Settings button
                document.getElementById('settings-button').addEventListener('click', () => {
                    this.openSettings();
                });

                // Click outside modal to close
                document.getElementById('settings-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'settings-modal') {
                        this.closeSettings();
                    }
                });

                // Tab switching
                document.querySelectorAll('.settings-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabName = e.target.dataset.tab;
                        this.switchSettingsTab(tabName);
                    });
                });

                // Visible columns input
                document.getElementById('visible-columns').addEventListener('change', (e) => {
                    this.visibleColumns = parseInt(e.target.value);
                    this.saveVisibleColumns();
                    this.render();
                });

                // Add column button
                document.getElementById('add-column-btn').addEventListener('click', () => {
                    this.addColumn();
                });

                // GitHub sync inputs
                document.getElementById('github-token').addEventListener('change', (e) => {
                    this.githubToken = e.target.value;
                    localStorage.setItem('catch-all-github-token', this.githubToken);
                    this.updateStatusBarMessage();
                });

                document.getElementById('github-repo').addEventListener('change', (e) => {
                    this.githubRepo = e.target.value;
                    localStorage.setItem('catch-all-github-repo', this.githubRepo);
                    this.updateStatusBarMessage();
                });

                // Sync now button
                document.getElementById('sync-now-btn').addEventListener('click', () => {
                    this.manualSync();
                });

                // Backup & Restore
                document.getElementById('backup-download-btn').addEventListener('click', () => {
                    this.downloadBackup();
                });

                document.getElementById('backup-upload-btn').addEventListener('click', () => {
                    document.getElementById('backup-upload').click();
                });

                document.getElementById('backup-upload').addEventListener('change', (e) => {
                    this.restoreBackup(e);
                });
            }

            toggleEditMode() {
                this.editMode = !this.editMode;
                const indicator = document.getElementById('edit-indicator');
                
                if (this.editMode) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                    // Save all columns when exiting edit mode
                    this.saveAllColumns();
                }
                
                this.render();
            }

            saveAllColumns() {
                const textareas = document.querySelectorAll('.markdown-editor');
                textareas.forEach((textarea, index) => {
                    if (this.columns[index]) {
                        this.columns[index].content = textarea.value;
                    }
                });
                this.saveColumns();
            }

            render() {
                const app = document.getElementById('app');
                const columnWidth = 100 / this.visibleColumns;
                
                app.innerHTML = '';
                
                this.columns.forEach((column, index) => {
                    const columnEl = document.createElement('div');
                    columnEl.className = 'column';
                    columnEl.style.width = `${columnWidth}%`;
                    
                    // Title
                    const titleEl = document.createElement('div');
                    titleEl.className = 'column-title';
                    titleEl.textContent = column.title;
                    titleEl.setAttribute('contenteditable', 'false');
                    titleEl.dataset.index = index;
                    
                    titleEl.addEventListener('dblclick', () => {
                        this.startTitleEdit(index, titleEl);
                    });
                    
                    titleEl.addEventListener('blur', () => {
                        if (this.editingTitle === index) {
                            this.exitTitleEdit();
                        }
                    });
                    
                    titleEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.exitTitleEdit();
                        }
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            this.exitTitleEdit();
                        }
                    });
                    
                    columnEl.appendChild(titleEl);
                    
                    // Content
                    const contentEl = document.createElement('div');
                    contentEl.className = 'column-content';
                    
                    if (this.editMode) {
                        const textarea = document.createElement('textarea');
                        textarea.className = 'markdown-editor';
                        textarea.value = column.content;
                        textarea.dataset.index = index;
                        
                        // Auto-save on input
                        textarea.addEventListener('input', () => {
                            this.columns[index].content = textarea.value;
                            this.saveColumns();
                        });
                        
                        // Markdown typing helper
                        textarea.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                this.handleMarkdownEnter(e, textarea);
                            } else if (e.key === 'Tab') {
                                this.handleMarkdownTab(e, textarea);
                            }
                        });
                        
                        contentEl.appendChild(textarea);
                    } else {
                        const viewEl = document.createElement('div');
                        viewEl.className = 'markdown-view';
                        
                        // Convert shorthand to standard format before parsing
                        let content = column.content
                            .replace(/^(\s*)\+\s+(.*)$/gm, '$1- [ ] $2')  // + â†’ - [ ]
                            .replace(/^(\s*)x\s+(.*)$/gm, '$1- [x] $2');  // x â†’ - [x]
                        
                        // Parse markdown and process task lists
                        let html = marked.parse(content);
                        
                        // Replace task list items (do this BEFORE replacing standalone checkboxes)
                        // Checked tasks with strikethrough
                        html = html.replace(/<li><input\s+checked(?:="")?\s+disabled(?:="")?\s+type="checkbox">\s*(.*?)<\/li>/gi, '<li style="list-style: none; margin-left: -20px;"><span class="task-checkbox checked" data-column="' + index + '">âœ“</span> <s>$1</s></li>');
                        // Unchecked tasks
                        html = html.replace(/<li><input\s+disabled(?:="")?\s+type="checkbox">\s*(.*?)<\/li>/g, '<li style="list-style: none; margin-left: -20px;"><span class="task-checkbox" data-column="' + index + '">â–¡</span> $1</li>');
                        html = html.replace(/<li><input\s+type="checkbox"\s+disabled(?:="")?>\s*(.*?)<\/li>/g, '<li style="list-style: none; margin-left: -20px;"><span class="task-checkbox" data-column="' + index + '">â–¡</span> $1</li>');
                        
                        viewEl.innerHTML = html;
                        
                        // Add click handlers for task checkboxes
                        viewEl.querySelectorAll('.task-checkbox').forEach(checkbox => {
                            checkbox.style.cursor = 'pointer';
                            checkbox.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const columnIndex = parseInt(checkbox.dataset.column);
                                this.toggleTask(columnIndex, checkbox);
                            });
                        });
                        
                        // Double-click to enter edit mode
                        viewEl.addEventListener('dblclick', () => {
                            if (!this.editMode) {
                                this.toggleEditMode();
                            }
                        });
                        
                        contentEl.appendChild(viewEl);
                    }
                    
                    columnEl.appendChild(contentEl);
                    app.appendChild(columnEl);
                });
            }

            startTitleEdit(index, element) {
                this.editingTitle = index;
                element.setAttribute('contenteditable', 'true');
                element.classList.add('editing');
                element.focus();
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(element);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }

            exitTitleEdit() {
                if (this.editingTitle === null) return;
                
                const titleEl = document.querySelector(`.column-title[data-index="${this.editingTitle}"]`);
                if (titleEl) {
                    titleEl.setAttribute('contenteditable', 'false');
                    titleEl.classList.remove('editing');
                    this.columns[this.editingTitle].title = titleEl.textContent;
                    this.saveColumns();
                }
                
                this.editingTitle = null;
            }

            openSettings() {
                document.getElementById('settings-modal').classList.add('active');
                document.getElementById('visible-columns').value = this.visibleColumns;
                document.getElementById('github-token').value = this.githubToken;
                document.getElementById('github-repo').value = this.githubRepo;
                this.renderColumnsList();
            }

            switchSettingsTab(tabName) {
                // Update tab buttons
                document.querySelectorAll('.settings-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`tab-${tabName}`).classList.add('active');
            }

            closeSettings() {
                document.getElementById('settings-modal').classList.remove('active');
            }

            renderColumnsList() {
                const list = document.getElementById('columns-list');
                list.innerHTML = '';
                
                this.columns.forEach((column, index) => {
                    const item = document.createElement('div');
                    item.className = 'column-item';
                    item.draggable = true;
                    item.dataset.index = index;
                    
                    // Drag handle
                    const dragHandle = document.createElement('span');
                    dragHandle.className = 'column-item-drag-handle';
                    dragHandle.textContent = 'â‹®â‹®';
                    
                    const span = document.createElement('span');
                    span.textContent = `${index + 1}. ${column.title}`;
                    
                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.className = 'column-item-buttons';
                    
                    const button = document.createElement('button');
                    button.textContent = 'Remove';
                    button.addEventListener('click', () => {
                        this.removeColumn(index);
                    });
                    
                    // Drag events
                    item.addEventListener('dragstart', (e) => {
                        item.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', index);
                    });
                    
                    item.addEventListener('dragend', () => {
                        item.classList.remove('dragging');
                        document.querySelectorAll('.column-item').forEach(el => {
                            el.classList.remove('drag-over');
                        });
                    });
                    
                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        item.classList.add('drag-over');
                    });
                    
                    item.addEventListener('dragleave', () => {
                        item.classList.remove('drag-over');
                    });
                    
                    item.addEventListener('drop', (e) => {
                        e.preventDefault();
                        item.classList.remove('drag-over');
                        
                        const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const toIndex = parseInt(item.dataset.index);
                        
                        if (fromIndex !== toIndex) {
                            this.reorderColumn(fromIndex, toIndex);
                        }
                    });
                    
                    buttonsDiv.appendChild(button);
                    item.appendChild(dragHandle);
                    item.appendChild(span);
                    item.appendChild(buttonsDiv);
                    list.appendChild(item);
                });
            }

            reorderColumn(fromIndex, toIndex) {
                const [movedColumn] = this.columns.splice(fromIndex, 1);
                this.columns.splice(toIndex, 0, movedColumn);
                this.saveColumns();
                this.renderColumnsList();
                this.render();
            }

            addColumn() {
                const newId = this.columns.length > 0 ? Math.max(...this.columns.map(c => c.id)) + 1 : 1;
                this.columns.push({
                    id: newId,
                    title: `Column ${newId}`,
                    content: '# New Column\n\nStart typing...'
                });
                this.saveColumns();
                this.renderColumnsList();
                this.render();
            }

            removeColumn(index) {
                if (this.columns.length <= 1) {
                    alert('You must have at least one column!');
                    return;
                }
                
                if (confirm(`Remove "${this.columns[index].title}"?`)) {
                    this.columns.splice(index, 1);
                    this.saveColumns();
                    this.renderColumnsList();
                    this.render();
                }
            }

            // GitHub Sync Methods
            debouncedSyncToGitHub() {
                clearTimeout(this.syncTimeout);
                this.syncTimeout = setTimeout(() => {
                    this.syncToGitHub();
                }, 2000); // Wait 2 seconds after last change
            }

            async syncToGitHub() {
                if (!this.githubToken || !this.githubRepo || this.syncInProgress) {
                    console.log('Sync skipped - already in progress or not configured');
                    return;
                }

                this.syncInProgress = true;
                this.showStatusBar('â¬† Sync in progress');
                const fileName = 'catch-all-data.json';
                const data = {
                    columns: this.columns,
                    visibleColumns: this.visibleColumns,
                    lastSync: new Date().toISOString()
                };

                try {
                    console.log('Syncing to GitHub...');
                    // Check if file exists
                    const checkUrl = `https://api.github.com/repos/${this.githubRepo}/contents/${fileName}`;
                    const checkResponse = await fetch(checkUrl, {
                        headers: {
                            'Authorization': `Bearer ${this.githubToken}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    let sha = null;
                    if (checkResponse.ok) {
                        const fileData = await checkResponse.json();
                        sha = fileData.sha;
                        console.log('File exists, updating with sha:', sha);
                    } else {
                        console.log('File does not exist, creating new file');
                    }

                    // Create or update file
                    // Properly encode UTF-8 to base64 to handle emojis, accents, and special characters
                    const jsonString = JSON.stringify(data, null, 2);
                    const utf8Bytes = new TextEncoder().encode(jsonString);
                    const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
                    const content = btoa(binaryString);
                    const updateUrl = `https://api.github.com/repos/${this.githubRepo}/contents/${fileName}`;
                    const updateResponse = await fetch(updateUrl, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.githubToken}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Update catch-all data - ${new Date().toLocaleString()}`,
                            content: content,
                            sha: sha
                        })
                    });

                    if (!updateResponse.ok) {
                        const errorData = await updateResponse.json();
                        console.error('GitHub update failed:', errorData);
                        throw new Error(`GitHub API error: ${updateResponse.status} - ${errorData.message || 'Unknown error'}`);
                    }

                    this.lastSyncTime = new Date();
                    console.log('Sync to GitHub successful!');
                    this.showSyncStatus('Synced to GitHub successfully', 'success');
                    this.showStatusBar('â†‘ Sync done âœ“');
                } catch (error) {
                    console.error('Sync to GitHub failed:', error);
                    this.showSyncStatus(`Sync failed: ${error.message}`, 'error');
                    this.showStatusBar('ðŸ”º SYNC FAILED', true);
                } finally {
                    this.syncInProgress = false;
                }
            }

            async syncFromGitHub() {
                if (!this.githubToken || !this.githubRepo || this.syncInProgress) {
                    return;
                }

                this.syncInProgress = true;
                this.showStatusBar('â¬‡ Sync in progress');
                const fileName = 'catch-all-data.json';

                try {
                    const url = `https://api.github.com/repos/${this.githubRepo}/contents/${fileName}`;
                    console.log('Fetching from GitHub:', url);
                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Bearer ${this.githubToken}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 404) {
                            console.log('File not found, creating initial file...');
                            // File doesn't exist yet, create it
                            this.syncInProgress = false; // Release lock before calling syncToGitHub
                            await this.syncToGitHub();
                            return;
                        }
                        const errorData = await response.json();
                        throw new Error(`GitHub API error: ${response.status} - ${errorData.message || 'Unknown error'}`);
                    }

                    const fileData = await response.json();
                    // Properly decode base64 to UTF-8 to handle emojis, accents, and special characters
                    const binaryString = atob(fileData.content);
                    const utf8Bytes = Uint8Array.from(binaryString, char => char.charCodeAt(0));
                    const jsonString = new TextDecoder().decode(utf8Bytes);
                    const content = JSON.parse(jsonString);

                    // Update local data
                    this.columns = content.columns;
                    this.visibleColumns = content.visibleColumns;
                    this.lastSyncTime = new Date();

                    // Save to localStorage
                    localStorage.setItem('catch-all-columns', JSON.stringify(this.columns));
                    localStorage.setItem('catch-all-visible-columns', this.visibleColumns.toString());

                    this.render();
                    this.showSyncStatus('Synced from GitHub successfully', 'success');
                    this.showStatusBar('â†“ Sync done âœ“');
                } catch (error) {
                    console.error('Sync from GitHub failed:', error);
                    this.showSyncStatus(`Sync failed: ${error.message}`, 'error');
                    this.showStatusBar('ðŸ”» SYNC FAILED', true);
                } finally {
                    this.syncInProgress = false;
                }
            }

            async manualSync() {
                console.log('Manual sync started...');
                this.showSyncStatus('Syncing...', 'info');
                this.showStatusBar('â¬‡ Sync in progress');
                await this.syncFromGitHub();
                console.log('Manual sync completed');
            }

            downloadBackup() {
                const data = {
                    columns: this.columns,
                    visibleColumns: this.visibleColumns,
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };

                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `cccolumns-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                this.showBackupStatus('Backup downloaded successfully!', 'success');
            }

            async restoreBackup(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    // Validate the backup data
                    if (!data.columns || !Array.isArray(data.columns)) {
                        throw new Error('Invalid backup file format');
                    }

                    // Confirm with user before restoring
                    if (!confirm('This will replace all current data with the backup. Continue?')) {
                        this.showBackupStatus('Restore cancelled', 'info');
                        event.target.value = ''; // Reset file input
                        return;
                    }

                    // Restore the data
                    this.columns = data.columns;
                    if (data.visibleColumns) {
                        this.visibleColumns = data.visibleColumns;
                        this.saveVisibleColumns();
                    }
                    this.saveColumns();
                    this.render();
                    this.renderColumnsList();

                    this.showBackupStatus('Backup restored successfully!', 'success');
                    this.showStatusBar('Backup restored successfully');
                } catch (error) {
                    console.error('Error restoring backup:', error);
                    this.showBackupStatus('Error: Invalid backup file', 'error');
                } finally {
                    event.target.value = ''; // Reset file input
                }
            }

            showBackupStatus(message, type) {
                const statusEl = document.getElementById('backup-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    const colors = {
                        success: '#28a745',
                        error: '#dc3545',
                        info: '#007bff'
                    };
                    statusEl.style.color = colors[type] || '#666';

                    // Hide success messages after 3 seconds
                    if (type === 'success') {
                        setTimeout(() => {
                            statusEl.textContent = '';
                        }, 3000);
                    }
                }
            }

            showSyncStatus(message, type) {
                console.log(`Sync status: ${message} (${type})`);
                const statusEl = document.getElementById('sync-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.className = `sync-status ${type}`;
                    statusEl.style.display = 'block';

                    // Hide success messages after 3 seconds
                    if (type === 'success') {
                        setTimeout(() => {
                            statusEl.style.display = 'none';
                        }, 3000);
                    }
                } else {
                    console.error('Sync status element not found!');
                }
            }

            // Markdown typing helpers
            handleMarkdownEnter(e, textarea) {
                const value = textarea.value;
                const cursorPos = textarea.selectionStart;
                const textBeforeCursor = value.substring(0, cursorPos);
                const currentLine = textBeforeCursor.split('\n').pop();
                
                // Task list with + (unchecked shorthand)
                const plusMatch = currentLine.match(/^(\s*)(\+)\s+(.*)$/);
                if (plusMatch) {
                    e.preventDefault();
                    const [, indent, , content] = plusMatch;
                    
                    if (!content.trim()) {
                        const lineStart = cursorPos - currentLine.length;
                        textarea.value = value.substring(0, lineStart) + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = lineStart;
                    } else {
                        const newLine = `\n${indent}+ `;
                        textarea.value = value.substring(0, cursorPos) + newLine + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = cursorPos + newLine.length;
                    }
                    textarea.dispatchEvent(new Event('input'));
                    return;
                }
                
                // Task list with x (checked shorthand)
                const xMatch = currentLine.match(/^(\s*)(x)\s+(.*)$/);
                if (xMatch) {
                    e.preventDefault();
                    const [, indent, , content] = xMatch;
                    
                    if (!content.trim()) {
                        const lineStart = cursorPos - currentLine.length;
                        textarea.value = value.substring(0, lineStart) + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = lineStart;
                    } else {
                        const newLine = `\n${indent}x `;
                        textarea.value = value.substring(0, cursorPos) + newLine + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = cursorPos + newLine.length;
                    }
                    textarea.dispatchEvent(new Event('input'));
                    return;
                }
                
                // Unordered list (-, *, +)
                const unorderedMatch = currentLine.match(/^(\s*)([-*+])\s+(.*)$/);
                if (unorderedMatch) {
                    e.preventDefault();
                    const [, indent, bullet, content] = unorderedMatch;
                    
                    // If the line is empty (just the bullet), remove it and exit list
                    if (!content.trim()) {
                        const lineStart = cursorPos - currentLine.length;
                        textarea.value = value.substring(0, lineStart) + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = lineStart;
                    } else {
                        // Continue the list
                        const newLine = `\n${indent}${bullet} `;
                        textarea.value = value.substring(0, cursorPos) + newLine + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = cursorPos + newLine.length;
                    }
                    textarea.dispatchEvent(new Event('input'));
                    return;
                }
                
                // Ordered list (1., 2., etc.)
                const orderedMatch = currentLine.match(/^(\s*)(\d+)\.\s+(.*)$/);
                if (orderedMatch) {
                    e.preventDefault();
                    const [, indent, num, content] = orderedMatch;
                    
                    // If the line is empty, remove it and exit list
                    if (!content.trim()) {
                        const lineStart = cursorPos - currentLine.length;
                        textarea.value = value.substring(0, lineStart) + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = lineStart;
                    } else {
                        // Continue with next number
                        const nextNum = parseInt(num) + 1;
                        const newLine = `\n${indent}${nextNum}. `;
                        textarea.value = value.substring(0, cursorPos) + newLine + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = cursorPos + newLine.length;
                    }
                    textarea.dispatchEvent(new Event('input'));
                    return;
                }
                
                // Blockquote (>)
                const blockquoteMatch = currentLine.match(/^(\s*)(>+)\s+(.*)$/);
                if (blockquoteMatch) {
                    e.preventDefault();
                    const [, indent, quotes, content] = blockquoteMatch;
                    
                    if (!content.trim()) {
                        const lineStart = cursorPos - currentLine.length;
                        textarea.value = value.substring(0, lineStart) + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = lineStart;
                    } else {
                        const newLine = `\n${indent}${quotes} `;
                        textarea.value = value.substring(0, cursorPos) + newLine + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = cursorPos + newLine.length;
                    }
                    textarea.dispatchEvent(new Event('input'));
                    return;
                }
                
                // Task list (- [ ] or - [x])
                const taskMatch = currentLine.match(/^(\s*)([-*+])\s+\[([x ])\]\s+(.*)$/);
                if (taskMatch) {
                    e.preventDefault();
                    const [, indent, bullet, , content] = taskMatch;
                    
                    if (!content.trim()) {
                        const lineStart = cursorPos - currentLine.length;
                        textarea.value = value.substring(0, lineStart) + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = lineStart;
                    } else {
                        const newLine = `\n${indent}${bullet} [ ] `;
                        textarea.value = value.substring(0, cursorPos) + newLine + value.substring(cursorPos);
                        textarea.selectionStart = textarea.selectionEnd = cursorPos + newLine.length;
                    }
                    textarea.dispatchEvent(new Event('input'));
                    return;
                }
            }

            handleMarkdownTab(e, textarea) {
                e.preventDefault();
                const value = textarea.value;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                
                // Insert tab (2 spaces)
                const tab = '  ';
                textarea.value = value.substring(0, start) + tab + value.substring(end);
                textarea.selectionStart = textarea.selectionEnd = start + tab.length;
                textarea.dispatchEvent(new Event('input'));
            }

            toggleTask(columnIndex, checkboxElement) {
                const li = checkboxElement.closest('li');
                const taskText = li.textContent.trim();
                // Remove the checkbox symbol from the text
                const taskContent = taskText.substring(1).trim();
                
                // Get the current column content
                let content = this.columns[columnIndex].content;
                const lines = content.split('\n');
                
                // Find and toggle the matching task
                let found = false;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    // Check if this line contains our task
                    if (line.includes(taskContent)) {
                        if (checkboxElement.classList.contains('checked')) {
                            // Mark as unchecked
                            // Handle both standard [x] and shorthand x
                            if (line.match(/\[x\]/i)) {
                                lines[i] = line.replace(/\[x\]/i, '[ ]');
                            } else if (line.match(/^(\s*)x\s+/)) {
                                lines[i] = line.replace(/^(\s*)x\s+/, '$1+ ');
                            }
                        } else {
                            // Mark as checked
                            // Handle both standard [ ] and shorthand +
                            if (line.match(/\[\s*\]/)) {
                                lines[i] = line.replace(/\[\s*\]/, '[x]');
                            } else if (line.match(/^(\s*)\+\s+/)) {
                                lines[i] = line.replace(/^(\s*)\+\s+/, '$1x ');
                            }
                        }
                        found = true;
                        break;
                    }
                }
                
                if (found) {
                    // Update the column content
                    this.columns[columnIndex].content = lines.join('\n');
                    this.saveColumns();
                    this.render();
                }
            }

            showStatusBar(message, isError = false) {
                const statusEl = document.getElementById('status-message');
                if (statusEl) {
                    statusEl.textContent = message;
                    if (isError) {
                        statusEl.style.color = '#dc3545';
                        statusEl.style.fontWeight = 'bold';
                    } else {
                        statusEl.style.color = '#666';
                        statusEl.style.fontWeight = 'normal';
                    }
                }
            }

            updateStatusBarMessage() {
                const statusEl = document.getElementById('status-message');
                if (!statusEl) return;

                if (this.localOnlyMode) {
                    statusEl.innerHTML = 'Local-only mode â€” data saved in browser only. <a href="#" id="install-settings-link" style="color: #007bff; text-decoration: underline; cursor: pointer;">See installation guide</a>';
                    
                    // Add click handler for the link
                    const link = document.getElementById('install-settings-link');
                    if (link) {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.openSettings();
                            this.switchSettingsTab('install');
                        });
                    }
                } else if (!this.githubToken || !this.githubRepo) {
                    statusEl.innerHTML = 'Saving locally only â€” <a href="#" id="github-settings-link" style="color: #007bff; text-decoration: underline; cursor: pointer;">configure GitHub in settings</a> for cloud backup';
                    
                    // Add click handler for the link
                    const link = document.getElementById('github-settings-link');
                    if (link) {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.openSettings();
                            this.switchSettingsTab('sync');
                        });
                    }
                } else {
                    statusEl.textContent = '';
                }
            }
        }

        // Check auth on load - runs after class is defined
        if (checkAuth()) {
            showApp();
        } else {
            showLogin();
        }
    </script>
</body>
</html>
